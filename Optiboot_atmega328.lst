
Optiboot_atmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00008220  000006b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000620  00007c00  00007c00  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .version      00000002  00007ffe  00007ffe  000006b4  2**0
                  CONTENTS, READONLY
  3 .bss          00000001  00800100  00800100  000006b4  2**0
                  ALLOC
  4 .comment      0000002f  00000000  00000000  000006b6  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000028  00000000  00000000  000006e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000008b8  00000000  00000000  0000070d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002bf  00000000  00000000  00000fc5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000786  00000000  00000000  00001284  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000ec  00000000  00000000  00001a0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000220  00000000  00000000  00001af8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007d8  00000000  00000000  00001d18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  000024f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007c00 <main>:
  //  SP points to RAMEND
  //  r1 contains zero
  //
  // If not, uncomment the following instructions:
  // cli();
  asm volatile ("clr __zero_reg__");
    7c00:	11 24       	eor	r1, r1
#if defined(__AVR_ATmega8__) || defined (__AVR_ATmega32__)
  SP=RAMEND;  // This is done by hardware reset
#endif

  // Adaboot no-wait mod
  ch = MCUSR;
    7c02:	c4 b7       	in	r28, 0x34	; 52
  MCUSR = 0;
    7c04:	14 be       	out	0x34, r1	; 52
   
#ifdef DEBUG_ON  
    putch('S');
    7c06:	83 e5       	ldi	r24, 0x53	; 83
    7c08:	bc d0       	rcall	.+376    	; 0x7d82 <putch>
#endif

  if (!(ch & _BV(EXTRF))) //if not external reset
    7c0a:	c1 fd       	sbrc	r28, 1
    7c0c:	09 c0       	rjmp	.+18     	; 0x7c20 <main+0x20>
  {
    if (ch & _BV(WDRF)) //if reset by watchdog
      CheckFlashImage();
    7c0e:	c3 fd       	sbrc	r28, 3
#ifdef DEBUG_ON
    putch('A');
    7c10:	99 d1       	rcall	.+818    	; 0x7f44 <CheckFlashImage>
    7c12:	81 e4       	ldi	r24, 0x41	; 65
    7c14:	b6 d0       	rcall	.+364    	; 0x7d82 <putch>
#endif
    SPCR &= ~_BV(SPE) & ~_BV(MSTR);
    7c16:	8c b5       	in	r24, 0x2c	; 44
    7c18:	8f 7a       	andi	r24, 0xAF	; 175
    appStart(ch);
    7c1a:	8c bd       	out	0x2c, r24	; 44
    7c1c:	8c 2f       	mov	r24, r28
    7c1e:	fa d2       	rcall	.+1524   	; 0x8214 <appStart>
  }

#if LED_START_FLASHES > 0
  // Set up Timer 1 for timeout counter
  TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7c20:	85 e0       	ldi	r24, 0x05	; 5
    7c22:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UART_SRA = _BV(U2X0); //Double speed mode USART0
    7c26:	82 e0       	ldi	r24, 0x02	; 2
    7c28:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
  UART_SRB = _BV(RXEN0) | _BV(TXEN0);
    7c2c:	88 e1       	ldi	r24, 0x18	; 24
    7c2e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  UART_SRC = _BV(UCSZ00) | _BV(UCSZ01);
    7c32:	86 e0       	ldi	r24, 0x06	; 6
    7c34:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
  UART_SRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
    7c38:	80 e1       	ldi	r24, 0x10	; 16
    7c3a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
#endif
#endif


  // Set up watchdog to trigger after 500ms
  watchdogConfig(WATCHDOG_1S);
    7c3e:	8e e0       	ldi	r24, 0x0E	; 14
    7c40:	76 d1       	rcall	.+748    	; 0x7f2e <watchdogConfig>

#if (LED_START_FLASHES > 0) || defined(LED_DATA_FLASH)
  /* Set LED pin as output */
  LED_DDR |= _BV(LED);
    7c42:	39 9a       	sbi	0x07, 1	; 7
    7c44:	86 e0       	ldi	r24, 0x06	; 6
}

#if LED_START_FLASHES > 0
void flash_led(uint8_t count) {
  do {
    TCNT1 = -(F_CPU/(1024*16));
    7c46:	20 e3       	ldi	r18, 0x30	; 48
    7c48:	3c ef       	ldi	r19, 0xFC	; 252
    TIFR1 = _BV(TOV1);
    7c4a:	91 e0       	ldi	r25, 0x01	; 1
}

#if LED_START_FLASHES > 0
void flash_led(uint8_t count) {
  do {
    TCNT1 = -(F_CPU/(1024*16));
    7c4c:	30 93 85 00 	sts	0x0085, r19	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    7c50:	20 93 84 00 	sts	0x0084, r18	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    TIFR1 = _BV(TOV1);
    7c54:	96 bb       	out	0x16, r25	; 22
    while(!(TIFR1 & _BV(TOV1)));
    7c56:	b0 9b       	sbis	0x16, 0	; 22
    7c58:	fe cf       	rjmp	.-4      	; 0x7c56 <main+0x56>
#if defined(__AVR_ATmega8__)  || defined (__AVR_ATmega32__)
    LED_PORT ^= _BV(LED);
#else
    LED_PIN |= _BV(LED);
    7c5a:	31 9a       	sbi	0x06, 1	; 6
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7c5c:	a8 95       	wdr
    7c5e:	81 50       	subi	r24, 0x01	; 1
    LED_PORT ^= _BV(LED);
#else
    LED_PIN |= _BV(LED);
#endif
    watchdogReset();
  } while (--count);
    7c60:	a9 f7       	brne	.-22     	; 0x7c4c <main+0x4c>
    7c62:	c0 e0       	ldi	r28, 0x00	; 0
    7c64:	d0 e0       	ldi	r29, 0x00	; 0
      ch = SPM_PAGESIZE / 2;
      do {
        uint16_t a;
        a = *bufPtr++;
        a |= (*bufPtr++) << 8;
        __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7c66:	01 e0       	ldi	r16, 0x01	; 1
        addrPtr += 2;
      } while (--ch);

      // Write from programming buffer
      __boot_page_write_short((uint16_t)(void*)address);
    7c68:	25 e0       	ldi	r18, 0x05	; 5
      boot_spm_busy_wait();

#if defined(RWWSRE)
      // Reenable read access to flash
      boot_rww_enable();
    7c6a:	f2 2e       	mov	r15, r18

      // If we are in NRWW section, page erase has to be delayed until now.
      // Todo: Take RAMPZ into account (not doing so just means that we will
      //  treat the top of both "pages" of flash as NRWW, for a slight speed
      //  decrease, so fixing this is not urgent.)
      if (address >= NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
    7c6c:	31 e1       	ldi	r19, 0x11	; 17
#endif

  /* Forever loop */
  for (;;) {
    /* get character from UART */
    ch = getch();
    7c6e:	e3 2e       	mov	r14, r19

    if(ch == STK_GET_PARAMETER) {
    7c70:	13 e0       	ldi	r17, 0x03	; 3
    7c72:	4f d1       	rcall	.+670    	; 0x7f12 <getch>
      unsigned char which = getch();
    7c74:	81 34       	cpi	r24, 0x41	; 65
    7c76:	71 f4       	brne	.+28     	; 0x7c94 <main+0x94>
    7c78:	4c d1       	rcall	.+664    	; 0x7f12 <getch>
      verifySpace();
    7c7a:	d8 2e       	mov	r13, r24
    7c7c:	bc d2       	rcall	.+1400   	; 0x81f6 <verifySpace>
      if (which == 0x82) {
    7c7e:	82 e8       	ldi	r24, 0x82	; 130
    7c80:	d8 16       	cp	r13, r24
	/*
	 * Send optiboot version as "minor SW version"
	 */
	putch(OPTIBOOT_MINVER);
      } else if (which == 0x81) {
    7c82:	f9 f0       	breq	.+62     	; 0x7cc2 <main+0xc2>
    7c84:	e1 e8       	ldi	r30, 0x81	; 129
    7c86:	de 12       	cpse	r13, r30
	  putch(OPTIBOOT_MAJVER);
    7c88:	02 c0       	rjmp	.+4      	; 0x7c8e <main+0x8e>
    7c8a:	85 e0       	ldi	r24, 0x05	; 5
      } else {
	/*
	 * GET PARAMETER returns a generic 0x03 reply for
         * other parameters - enough to keep Avrdude happy
	 */
	putch(0x03);
    7c8c:	01 c0       	rjmp	.+2      	; 0x7c90 <main+0x90>
    7c8e:	83 e0       	ldi	r24, 0x03	; 3
    7c90:	78 d0       	rcall	.+240    	; 0x7d82 <putch>
      }
    }
    else if(ch == STK_SET_DEVICE) {
    7c92:	74 c0       	rjmp	.+232    	; 0x7d7c <main+0x17c>
    7c94:	82 34       	cpi	r24, 0x42	; 66
      // SET DEVICE is ignored
      getNch(20);
    7c96:	11 f4       	brne	.+4      	; 0x7c9c <main+0x9c>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
    7c98:	84 e1       	ldi	r24, 0x14	; 20
      // SET DEVICE EXT is ignored
      getNch(5);
    7c9a:	03 c0       	rjmp	.+6      	; 0x7ca2 <main+0xa2>
    7c9c:	85 34       	cpi	r24, 0x45	; 69
    7c9e:	19 f4       	brne	.+6      	; 0x7ca6 <main+0xa6>
    7ca0:	85 e0       	ldi	r24, 0x05	; 5
    }
    else if(ch == STK_LOAD_ADDRESS) {
    7ca2:	b1 d2       	rcall	.+1378   	; 0x8206 <getNch>
    7ca4:	6b c0       	rjmp	.+214    	; 0x7d7c <main+0x17c>
      // LOAD ADDRESS
      uint16_t newAddress;
      newAddress = getch();
    7ca6:	85 35       	cpi	r24, 0x55	; 85
    7ca8:	41 f4       	brne	.+16     	; 0x7cba <main+0xba>
      newAddress = (newAddress & 0xff) | (getch() << 8);
    7caa:	33 d1       	rcall	.+614    	; 0x7f12 <getch>
    7cac:	c8 2f       	mov	r28, r24
    7cae:	31 d1       	rcall	.+610    	; 0x7f12 <getch>
    7cb0:	d0 e0       	ldi	r29, 0x00	; 0
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif
      newAddress += newAddress; // Convert from word address to byte address
    7cb2:	d8 2b       	or	r29, r24
      address = newAddress;
      verifySpace();
    }
    else if(ch == STK_UNIVERSAL) {
    7cb4:	cc 0f       	add	r28, r28
      // UNIVERSAL command is ignored
      getNch(4);
    7cb6:	dd 1f       	adc	r29, r29
    7cb8:	60 c0       	rjmp	.+192    	; 0x7d7a <main+0x17a>
    7cba:	86 35       	cpi	r24, 0x56	; 86
      putch(0x00);
    7cbc:	21 f4       	brne	.+8      	; 0x7cc6 <main+0xc6>
    7cbe:	84 e0       	ldi	r24, 0x04	; 4
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
    7cc0:	a2 d2       	rcall	.+1348   	; 0x8206 <getNch>
    7cc2:	80 e0       	ldi	r24, 0x00	; 0
    7cc4:	e5 cf       	rjmp	.-54     	; 0x7c90 <main+0x90>
      // PROGRAM PAGE - we support flash programming only, not EEPROM
      uint8_t *bufPtr;
      uint16_t addrPtr;

      getch();			/* getlen() */
    7cc6:	84 36       	cpi	r24, 0x64	; 100
      length = getch();
    7cc8:	09 f0       	breq	.+2      	; 0x7ccc <main+0xcc>
    7cca:	3b c0       	rjmp	.+118    	; 0x7d42 <main+0x142>
    7ccc:	22 d1       	rcall	.+580    	; 0x7f12 <getch>
      getch();
    7cce:	21 d1       	rcall	.+578    	; 0x7f12 <getch>
    7cd0:	b8 2e       	mov	r11, r24

      // If we are in RWW section, immediately start page erase
      if (address < NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
    7cd2:	1f d1       	rcall	.+574    	; 0x7f12 <getch>
    7cd4:	c1 15       	cp	r28, r1
    7cd6:	f0 e7       	ldi	r31, 0x70	; 112
    7cd8:	df 07       	cpc	r29, r31
    7cda:	18 f4       	brcc	.+6      	; 0x7ce2 <main+0xe2>
    7cdc:	fe 01       	movw	r30, r28
    7cde:	17 bf       	out	0x37, r17	; 55
    7ce0:	e8 95       	spm
    7ce2:	c1 2c       	mov	r12, r1

      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
    7ce4:	dd 24       	eor	r13, r13
    7ce6:	d3 94       	inc	r13
    7ce8:	14 d1       	rcall	.+552    	; 0x7f12 <getch>
    7cea:	f6 01       	movw	r30, r12
    7cec:	81 93       	st	Z+, r24
      while (--length);
    7cee:	6f 01       	movw	r12, r30
    7cf0:	be 12       	cpse	r11, r30

      // If we are in NRWW section, page erase has to be delayed until now.
      // Todo: Take RAMPZ into account (not doing so just means that we will
      //  treat the top of both "pages" of flash as NRWW, for a slight speed
      //  decrease, so fixing this is not urgent.)
      if (address >= NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
    7cf2:	fa cf       	rjmp	.-12     	; 0x7ce8 <main+0xe8>
    7cf4:	c1 15       	cp	r28, r1
    7cf6:	f0 e7       	ldi	r31, 0x70	; 112
    7cf8:	df 07       	cpc	r29, r31
    7cfa:	18 f0       	brcs	.+6      	; 0x7d02 <main+0x102>
    7cfc:	fe 01       	movw	r30, r28
    7cfe:	17 bf       	out	0x37, r17	; 55

      // Read command terminator, start reply
      verifySpace();
    7d00:	e8 95       	spm
    7d02:	79 d2       	rcall	.+1266   	; 0x81f6 <verifySpace>

      // If only a partial page is to be programmed, the erase might not be complete.
      // So check that here
      boot_spm_busy_wait();
    7d04:	07 b6       	in	r0, 0x37	; 55
    7d06:	00 fc       	sbrc	r0, 0
    7d08:	fd cf       	rjmp	.-6      	; 0x7d04 <main+0x104>
    7d0a:	fe 01       	movw	r30, r28
    7d0c:	a0 e0       	ldi	r26, 0x00	; 0
    7d0e:	b1 e0       	ldi	r27, 0x01	; 1
      bufPtr = buff;
      addrPtr = (uint16_t)(void*)address;
      ch = SPM_PAGESIZE / 2;
      do {
        uint16_t a;
        a = *bufPtr++;
    7d10:	8c 91       	ld	r24, X
        a |= (*bufPtr++) << 8;
        __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7d12:	11 96       	adiw	r26, 0x01	; 1
    7d14:	2c 91       	ld	r18, X
    7d16:	11 97       	sbiw	r26, 0x01	; 1
    7d18:	90 e0       	ldi	r25, 0x00	; 0
    7d1a:	92 2b       	or	r25, r18
    7d1c:	0c 01       	movw	r0, r24
    7d1e:	07 bf       	out	0x37, r16	; 55
    7d20:	e8 95       	spm
        addrPtr += 2;
    7d22:	11 24       	eor	r1, r1
      } while (--ch);
    7d24:	32 96       	adiw	r30, 0x02	; 2
    7d26:	12 96       	adiw	r26, 0x02	; 2

      // Write from programming buffer
      __boot_page_write_short((uint16_t)(void*)address);
    7d28:	a0 38       	cpi	r26, 0x80	; 128
    7d2a:	81 e0       	ldi	r24, 0x01	; 1
      boot_spm_busy_wait();
    7d2c:	b8 07       	cpc	r27, r24
    7d2e:	81 f7       	brne	.-32     	; 0x7d10 <main+0x110>
    7d30:	fe 01       	movw	r30, r28

#if defined(RWWSRE)
      // Reenable read access to flash
      boot_rww_enable();
    7d32:	f7 be       	out	0x37, r15	; 55
    7d34:	e8 95       	spm
#endif

    }
    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
    7d36:	07 b6       	in	r0, 0x37	; 55
      // READ PAGE - we only read flash
      getch();			/* getlen() */
    7d38:	00 fc       	sbrc	r0, 0
      length = getch();
    7d3a:	fd cf       	rjmp	.-6      	; 0x7d36 <main+0x136>
    7d3c:	e7 be       	out	0x37, r14	; 55
    7d3e:	e8 95       	spm
      getch();
    7d40:	1d c0       	rjmp	.+58     	; 0x7d7c <main+0x17c>
    7d42:	84 37       	cpi	r24, 0x74	; 116

      verifySpace();
    7d44:	69 f4       	brne	.+26     	; 0x7d60 <main+0x160>
        //      while (--length);
        // read a Flash and increment the address (may increment RAMPZ)
        __asm__ ("elpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
#else
        // read a Flash byte and increment the address
        __asm__ ("lpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
    7d46:	e5 d0       	rcall	.+458    	; 0x7f12 <getch>
    7d48:	e4 d0       	rcall	.+456    	; 0x7f12 <getch>
#endif
        putch(ch);
    7d4a:	d8 2e       	mov	r13, r24
    7d4c:	e2 d0       	rcall	.+452    	; 0x7f12 <getch>
      } while (--length);
    7d4e:	53 d2       	rcall	.+1190   	; 0x81f6 <verifySpace>
    7d50:	fe 01       	movw	r30, r28
    7d52:	85 91       	lpm	r24, Z+
    7d54:	ef 01       	movw	r28, r30
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
    7d56:	15 d0       	rcall	.+42     	; 0x7d82 <putch>
    7d58:	da 94       	dec	r13
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
    7d5a:	d1 10       	cpse	r13, r1
    7d5c:	f9 cf       	rjmp	.-14     	; 0x7d50 <main+0x150>
      putch(SIGNATURE_0);
    7d5e:	0e c0       	rjmp	.+28     	; 0x7d7c <main+0x17c>
    7d60:	85 37       	cpi	r24, 0x75	; 117
    7d62:	39 f4       	brne	.+14     	; 0x7d72 <main+0x172>
      putch(SIGNATURE_1);
    7d64:	48 d2       	rcall	.+1168   	; 0x81f6 <verifySpace>
    7d66:	8e e1       	ldi	r24, 0x1E	; 30
    7d68:	0c d0       	rcall	.+24     	; 0x7d82 <putch>
      putch(SIGNATURE_2);
    7d6a:	85 e9       	ldi	r24, 0x95	; 149
    7d6c:	0a d0       	rcall	.+20     	; 0x7d82 <putch>
    }
    else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
    7d6e:	8f e0       	ldi	r24, 0x0F	; 15
    7d70:	8f cf       	rjmp	.-226    	; 0x7c90 <main+0x90>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
    7d72:	81 35       	cpi	r24, 0x51	; 81
    7d74:	11 f4       	brne	.+4      	; 0x7d7a <main+0x17a>
    7d76:	88 e0       	ldi	r24, 0x08	; 8
      verifySpace();
    }
    else {
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
    7d78:	da d0       	rcall	.+436    	; 0x7f2e <watchdogConfig>
    7d7a:	3d d2       	rcall	.+1146   	; 0x81f6 <verifySpace>
    }
    putch(STK_OK);
    7d7c:	80 e1       	ldi	r24, 0x10	; 16
    7d7e:	01 d0       	rcall	.+2      	; 0x7d82 <putch>
    7d80:	78 cf       	rjmp	.-272    	; 0x7c72 <main+0x72>

00007d82 <putch>:
  }
    7d82:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
}

void putch(char ch) {
#ifndef SOFT_UART
  while (!(UART_SRA & _BV(UDRE0)));
    7d86:	95 ff       	sbrs	r25, 5
    7d88:	fc cf       	rjmp	.-8      	; 0x7d82 <putch>
  UART_UDR = ch;
    7d8a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    7d8e:	08 95       	ret

00007d90 <FLASH_readByte>:

    putch('\n');
}

static inline uint8_t FLASH_readByte(uint32_t eeaddr)
{
    7d90:	cf 93       	push	r28
    7d92:	ab 01       	movw	r20, r22
    7d94:	bc 01       	movw	r22, r24
            goto error;		/* must send stop condition */
    }

#ifdef WORD_ADDRESS_16BIT
    m = 0;
    TWDR = ((uint16_t)eeaddr >> 8);		/* 16-bit word address device, send high 8 bits of addr */
    7d96:	35 2f       	mov	r19, r21
    7d98:	29 ec       	ldi	r18, 0xC9	; 201
    if (n++ >= MAX_ITER)
        return 0xFF;
begin:

    m=0;
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send start condition */
    7d9a:	e4 ea       	ldi	r30, 0xA4	; 164
    7d9c:	f4 ea       	ldi	r31, 0xA4	; 164
    }

    /* Note [10] */
    /* send SLA+W */
    m = 0;
    TWDR = sla | TW_WRITE;
    7d9e:	a0 ea       	ldi	r26, 0xA0	; 160
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    7da0:	94 e8       	ldi	r25, 0x84	; 132
            goto error;
    }

    /* send SLA+R */
    m = 0;
    TWDR = I2C_EEPROM_ADDR | TW_READ;
    7da2:	b1 ea       	ldi	r27, 0xA1	; 161
    7da4:	21 50       	subi	r18, 0x01	; 1
  /*
   * Note [8]
   * First cycle: master transmitter mode
   */
restart:
    if (n++ >= MAX_ITER)
    7da6:	09 f4       	brne	.+2      	; 0x7daa <FLASH_readByte+0x1a>
    7da8:	b1 c0       	rjmp	.+354    	; 0x7f0c <FLASH_readByte+0x17c>
        return 0xFF;
begin:

    m=0;
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send start condition */
    7daa:	f0 93 bc 00 	sts	0x00BC, r31	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
restart:
    if (n++ >= MAX_ITER)
        return 0xFF;
begin:

    m=0;
    7dae:	80 e0       	ldi	r24, 0x00	; 0
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send start condition */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    7db0:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7db4:	c7 fd       	sbrc	r28, 7
    7db6:	05 c0       	rjmp	.+10     	; 0x7dc2 <FLASH_readByte+0x32>
    7db8:	8f 5f       	subi	r24, 0xFF	; 255
    7dba:	8b 3f       	cpi	r24, 0xFB	; 251
    7dbc:	c9 f7       	brne	.-14     	; 0x7db0 <FLASH_readByte+0x20>
	if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('1');
    7dbe:	81 e3       	ldi	r24, 0x31	; 49
    7dc0:	0c c0       	rjmp	.+24     	; 0x7dda <FLASH_readByte+0x4a>
#endif
		return 0xFF; 
	}
	switch ((twst = TW_STATUS)) {
    7dc2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7dc6:	88 7f       	andi	r24, 0xF8	; 248
    7dc8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7dcc:	80 31       	cpi	r24, 0x10	; 16
    7dce:	39 f0       	breq	.+14     	; 0x7dde <FLASH_readByte+0x4e>
    7dd0:	88 33       	cpi	r24, 0x38	; 56
    7dd2:	59 f3       	breq	.-42     	; 0x7daa <FLASH_readByte+0x1a>
    7dd4:	88 30       	cpi	r24, 0x08	; 8
    7dd6:	19 f0       	breq	.+6      	; 0x7dde <FLASH_readByte+0x4e>
            break;
        case TW_MT_ARB_LOST:	// Note [9] 
            goto begin;
      default:
            #ifdef DEBUG_ON
                putch('M');
    7dd8:	8d e4       	ldi	r24, 0x4D	; 77
    7dda:	d3 df       	rcall	.-90     	; 0x7d82 <putch>
    7ddc:	97 c0       	rjmp	.+302    	; 0x7f0c <FLASH_readByte+0x17c>
    }

    /* Note [10] */
    /* send SLA+W */
    m = 0;
    TWDR = sla | TW_WRITE;
    7dde:	a0 93 bb 00 	sts	0x00BB, r26	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    7de2:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
				      // NB: do /not/ send stop condition
    }

    /* Note [10] */
    /* send SLA+W */
    m = 0;
    7de6:	80 e0       	ldi	r24, 0x00	; 0
    TWDR = sla | TW_WRITE;
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    7de8:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7dec:	c7 fd       	sbrc	r28, 7
    7dee:	05 c0       	rjmp	.+10     	; 0x7dfa <FLASH_readByte+0x6a>
    7df0:	8f 5f       	subi	r24, 0xFF	; 255
    7df2:	8b 3f       	cpi	r24, 0xFB	; 251
    7df4:	c9 f7       	brne	.-14     	; 0x7de8 <FLASH_readByte+0x58>
    if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('2');
    7df6:	82 e3       	ldi	r24, 0x32	; 50
    7df8:	76 c0       	rjmp	.+236    	; 0x7ee6 <FLASH_readByte+0x156>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7dfa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7dfe:	88 7f       	andi	r24, 0xF8	; 248
    7e00:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7e04:	80 32       	cpi	r24, 0x20	; 32
    7e06:	71 f2       	breq	.-100    	; 0x7da4 <FLASH_readByte+0x14>
    7e08:	88 33       	cpi	r24, 0x38	; 56
    7e0a:	79 f2       	breq	.-98     	; 0x7daa <FLASH_readByte+0x1a>
    7e0c:	88 31       	cpi	r24, 0x18	; 24
    7e0e:	09 f0       	breq	.+2      	; 0x7e12 <FLASH_readByte+0x82>
    7e10:	78 c0       	rjmp	.+240    	; 0x7f02 <FLASH_readByte+0x172>
            goto error;		/* must send stop condition */
    }

#ifdef WORD_ADDRESS_16BIT
    m = 0;
    TWDR = ((uint16_t)eeaddr >> 8);		/* 16-bit word address device, send high 8 bits of addr */
    7e12:	30 93 bb 00 	sts	0x00BB, r19	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    7e16:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
        default:
            goto error;		/* must send stop condition */
    }

#ifdef WORD_ADDRESS_16BIT
    m = 0;
    7e1a:	80 e0       	ldi	r24, 0x00	; 0
    TWDR = ((uint16_t)eeaddr >> 8);		/* 16-bit word address device, send high 8 bits of addr */
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)); /* wait for transmission */
    7e1c:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7e20:	c7 fd       	sbrc	r28, 7
    7e22:	05 c0       	rjmp	.+10     	; 0x7e2e <FLASH_readByte+0x9e>
    7e24:	8f 5f       	subi	r24, 0xFF	; 255
    7e26:	8b 3f       	cpi	r24, 0xFB	; 251
    7e28:	c9 f7       	brne	.-14     	; 0x7e1c <FLASH_readByte+0x8c>
	if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('3');
    7e2a:	83 e3       	ldi	r24, 0x33	; 51
    7e2c:	5c c0       	rjmp	.+184    	; 0x7ee6 <FLASH_readByte+0x156>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7e2e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7e32:	88 7f       	andi	r24, 0xF8	; 248
    7e34:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7e38:	88 32       	cpi	r24, 0x28	; 40
    7e3a:	a9 f4       	brne	.+42     	; 0x7e66 <FLASH_readByte+0xd6>
            goto error;		/* must send stop condition */
    }
#endif

    m = 0;
    TWDR = eeaddr;		/* low 8 bits of addr */
    7e3c:	40 93 bb 00 	sts	0x00BB, r20	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    7e40:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
        default:
            goto error;		/* must send stop condition */
    }
#endif

    m = 0;
    7e44:	80 e0       	ldi	r24, 0x00	; 0
    TWDR = eeaddr;		/* low 8 bits of addr */
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    7e46:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7e4a:	c7 fd       	sbrc	r28, 7
    7e4c:	05 c0       	rjmp	.+10     	; 0x7e58 <FLASH_readByte+0xc8>
    7e4e:	8f 5f       	subi	r24, 0xFF	; 255
    7e50:	8b 3f       	cpi	r24, 0xFB	; 251
    7e52:	c9 f7       	brne	.-14     	; 0x7e46 <FLASH_readByte+0xb6>
	if (m > MAX_TIMEOUT){
#ifdef DEBUG_ON
		putch('4');
    7e54:	84 e3       	ldi	r24, 0x34	; 52
    7e56:	47 c0       	rjmp	.+142    	; 0x7ee6 <FLASH_readByte+0x156>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7e58:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7e5c:	88 7f       	andi	r24, 0xF8	; 248
    7e5e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7e62:	88 32       	cpi	r24, 0x28	; 40
    7e64:	21 f0       	breq	.+8      	; 0x7e6e <FLASH_readByte+0xde>
    7e66:	88 33       	cpi	r24, 0x38	; 56
    7e68:	09 f4       	brne	.+2      	; 0x7e6c <FLASH_readByte+0xdc>
    7e6a:	9f cf       	rjmp	.-194    	; 0x7daa <FLASH_readByte+0x1a>
    7e6c:	4a c0       	rjmp	.+148    	; 0x7f02 <FLASH_readByte+0x172>
    /*
    * Note [12]
    * Next cycle(s): master receiver mode
    */
    m = 0;
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send (rep.) start condition */
    7e6e:	e0 93 bc 00 	sts	0x00BC, r30	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

    /*
    * Note [12]
    * Next cycle(s): master receiver mode
    */
    m = 0;
    7e72:	80 e0       	ldi	r24, 0x00	; 0
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send (rep.) start condition */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    7e74:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7e78:	c7 fd       	sbrc	r28, 7
    7e7a:	05 c0       	rjmp	.+10     	; 0x7e86 <FLASH_readByte+0xf6>
    7e7c:	8f 5f       	subi	r24, 0xFF	; 255
    7e7e:	8b 3f       	cpi	r24, 0xFB	; 251
    7e80:	c9 f7       	brne	.-14     	; 0x7e74 <FLASH_readByte+0xe4>
	if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('5');
    7e82:	85 e3       	ldi	r24, 0x35	; 53
    7e84:	30 c0       	rjmp	.+96     	; 0x7ee6 <FLASH_readByte+0x156>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7e86:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7e8a:	88 7f       	andi	r24, 0xF8	; 248
    7e8c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7e90:	80 31       	cpi	r24, 0x10	; 16
    7e92:	29 f0       	breq	.+10     	; 0x7e9e <FLASH_readByte+0x10e>
    7e94:	88 33       	cpi	r24, 0x38	; 56
    7e96:	09 f4       	brne	.+2      	; 0x7e9a <FLASH_readByte+0x10a>
    7e98:	88 cf       	rjmp	.-240    	; 0x7daa <FLASH_readByte+0x1a>
    7e9a:	88 30       	cpi	r24, 0x08	; 8
    7e9c:	91 f5       	brne	.+100    	; 0x7f02 <FLASH_readByte+0x172>
            goto error;
    }

    /* send SLA+R */
    m = 0;
    TWDR = I2C_EEPROM_ADDR | TW_READ;
    7e9e:	b0 93 bb 00 	sts	0x00BB, r27	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    7ea2:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
        default:
            goto error;
    }

    /* send SLA+R */
    m = 0;
    7ea6:	80 e0       	ldi	r24, 0x00	; 0
    TWDR = I2C_EEPROM_ADDR | TW_READ;
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)); /* wait for transmission */
    7ea8:	c0 91 bc 00 	lds	r28, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7eac:	c7 fd       	sbrc	r28, 7
    7eae:	05 c0       	rjmp	.+10     	; 0x7eba <FLASH_readByte+0x12a>
    7eb0:	8f 5f       	subi	r24, 0xFF	; 255
    7eb2:	8b 3f       	cpi	r24, 0xFB	; 251
    7eb4:	c9 f7       	brne	.-14     	; 0x7ea8 <FLASH_readByte+0x118>
	if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('6');
    7eb6:	86 e3       	ldi	r24, 0x36	; 54
    7eb8:	16 c0       	rjmp	.+44     	; 0x7ee6 <FLASH_readByte+0x156>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7eba:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7ebe:	88 7f       	andi	r24, 0xF8	; 248
    7ec0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7ec4:	88 33       	cpi	r24, 0x38	; 56
    7ec6:	09 f4       	brne	.+2      	; 0x7eca <FLASH_readByte+0x13a>
    7ec8:	70 cf       	rjmp	.-288    	; 0x7daa <FLASH_readByte+0x1a>
    7eca:	80 34       	cpi	r24, 0x40	; 64
    7ecc:	d1 f4       	brne	.+52     	; 0x7f02 <FLASH_readByte+0x172>
    twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA) /* Note [13] */;


    m = 0;
    twcr = _BV(TWINT) | _BV(TWEN); /* send NAK this time */
    TWCR = twcr;		/* clear int to start transmission */
    7ece:	84 e8       	ldi	r24, 0x84	; 132
    7ed0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>


    twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA) /* Note [13] */;


    m = 0;
    7ed4:	80 e0       	ldi	r24, 0x00	; 0
    twcr = _BV(TWINT) | _BV(TWEN); /* send NAK this time */
    TWCR = twcr;		/* clear int to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)); /* wait for transmission */
    7ed6:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7eda:	97 fd       	sbrc	r25, 7
    7edc:	06 c0       	rjmp	.+12     	; 0x7eea <FLASH_readByte+0x15a>
    7ede:	8f 5f       	subi	r24, 0xFF	; 255
    7ee0:	8b 3f       	cpi	r24, 0xFB	; 251
    7ee2:	c9 f7       	brne	.-14     	; 0x7ed6 <FLASH_readByte+0x146>
	if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('7');
    7ee4:	87 e3       	ldi	r24, 0x37	; 55
    7ee6:	4d df       	rcall	.-358    	; 0x7d82 <putch>
    7ee8:	0c c0       	rjmp	.+24     	; 0x7f02 <FLASH_readByte+0x172>
#endif
		goto error;
	}
	switch ((twst = TW_STATUS)) {
    7eea:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7eee:	88 7f       	andi	r24, 0xF8	; 248
    7ef0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    7ef4:	80 35       	cpi	r24, 0x50	; 80
    7ef6:	11 f0       	breq	.+4      	; 0x7efc <FLASH_readByte+0x16c>
    7ef8:	88 35       	cpi	r24, 0x58	; 88
    7efa:	19 f4       	brne	.+6      	; 0x7f02 <FLASH_readByte+0x172>
	      case TW_MR_DATA_ACK:
	      case TW_MR_DATA_NACK:
	          buf = TWDR;
    7efc:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	          break;
    7f00:	01 c0       	rjmp	.+2      	; 0x7f04 <FLASH_readByte+0x174>
    putch('\n');
}

static inline uint8_t FLASH_readByte(uint32_t eeaddr)
{
    uint8_t sla, twcr, n = 0, m = 0, buf=0xFF;
    7f02:	8f ef       	ldi	r24, 0xFF	; 255
	          goto error;
	  }

quit:
    /* Note [14] */
    TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
    7f04:	94 e9       	ldi	r25, 0x94	; 148
    7f06:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    return buf;
    7f0a:	01 c0       	rjmp	.+2      	; 0x7f0e <FLASH_readByte+0x17e>
   * Note [8]
   * First cycle: master transmitter mode
   */
restart:
    if (n++ >= MAX_ITER)
        return 0xFF;
    7f0c:	8f ef       	ldi	r24, 0xFF	; 255
    TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
    return buf;

error:
    goto quit;
}
    7f0e:	cf 91       	pop	r28
    7f10:	08 95       	ret

00007f12 <getch>:

#ifdef LED_DATA_FLASH
#if defined(__AVR_ATmega8__) || defined (__AVR_ATmega32__)
  LED_PORT ^= _BV(LED);
#else
  LED_PIN |= _BV(LED);
    7f12:	31 9a       	sbi	0x06, 1	; 6
      [uartBit] "I" (UART_RX_BIT)
    :
      "r25"
);
#else
  while(!(UART_SRA & _BV(RXC0)))
    7f14:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    7f18:	87 ff       	sbrs	r24, 7
    7f1a:	fc cf       	rjmp	.-8      	; 0x7f14 <getch+0x2>
    ;
  if (!(UART_SRA & _BV(FE0))) {
    7f1c:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    7f20:	84 fd       	sbrc	r24, 4
    7f22:	01 c0       	rjmp	.+2      	; 0x7f26 <getch+0x14>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7f24:	a8 95       	wdr
       * don't care that an invalid char is returned...)
       */
    watchdogReset();
  }
  
  ch = UART_UDR;
    7f26:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

#ifdef LED_DATA_FLASH
#if defined(__AVR_ATmega8__) || defined (__AVR_ATmega32__)
  LED_PORT ^= _BV(LED);
#else
  LED_PIN |= _BV(LED);
    7f2a:	31 9a       	sbi	0x06, 1	; 6
#endif
#endif

  return ch;
}
    7f2c:	08 95       	ret

00007f2e <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  if (x == WATCHDOG_OFF) MCUSR &= ~(_BV(WDRF));
    7f2e:	81 11       	cpse	r24, r1
    7f30:	03 c0       	rjmp	.+6      	; 0x7f38 <watchdogConfig+0xa>
    7f32:	94 b7       	in	r25, 0x34	; 52
    7f34:	97 7f       	andi	r25, 0xF7	; 247
    7f36:	94 bf       	out	0x34, r25	; 52
  WDTCSR = _BV(WDCE) | _BV(WDE);
    7f38:	98 e1       	ldi	r25, 0x18	; 24
    7f3a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
  WDTCSR = x;
    7f3e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    7f42:	08 95       	ret

00007f44 <CheckFlashImage>:
#define I2C_EEPROM_ADDR	0xA0  // default
#include "i2c.h"  // EEPROM routines are here
#endif	// USE_I2C_EEPROM


void CheckFlashImage() {
    7f44:	9f 92       	push	r9
    7f46:	af 92       	push	r10
    7f48:	bf 92       	push	r11
    7f4a:	cf 92       	push	r12
    7f4c:	df 92       	push	r13
    7f4e:	ef 92       	push	r14
    7f50:	ff 92       	push	r15
    7f52:	0f 93       	push	r16
    7f54:	1f 93       	push	r17
    7f56:	cf 93       	push	r28
#ifdef DEBUG_ON
  putch('F');
    7f58:	df 93       	push	r29
    7f5a:	86 e4       	ldi	r24, 0x46	; 70
#endif
  watchdogConfig(WATCHDOG_OFF);
    7f5c:	12 df       	rcall	.-476    	; 0x7d82 <putch>
    7f5e:	80 e0       	ldi	r24, 0x00	; 0
    7f60:	e6 df       	rcall	.-52     	; 0x7f2e <watchdogConfig>
{

    /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
#if defined(TWPS0)
    /* has prescaler (mega128 & newer) */
    TWSR = 0;
    7f62:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
#endif

#if F_CPU < 3600000UL
    TWBR = 10;
#else
    TWBR = ((F_CPU / 100000UL) - 16) / 2;
    7f66:	88 e4       	ldi	r24, 0x48	; 72
    7f68:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
#endif

    //TWDR = 0xFF; 
    TWCR = (1<<TWEN) | (0<<TWEA);
    7f6c:	84 e0       	ldi	r24, 0x04	; 4
    7f6e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

    putch('\n');
    7f72:	8a e0       	ldi	r24, 0x0A	; 10
    7f74:	06 df       	rcall	.-500    	; 0x7d82 <putch>


#ifdef USE_I2C_EEPROM
  EEPROM_init();
#ifdef DEBUG_ON
  putch('2');	// using I2C instead of SPI
    7f76:	82 e3       	ldi	r24, 0x32	; 50
  FLASH_UNSELECT;
#endif // USE_I2C_EPPROM
  
  //check if any flash image exists on external FLASH chip
  #ifdef DEBUG_ON
    putch(FLASH_readByte(0));
    7f78:	04 df       	rcall	.-504    	; 0x7d82 <putch>
    7f7a:	60 e0       	ldi	r22, 0x00	; 0
    7f7c:	70 e0       	ldi	r23, 0x00	; 0
    7f7e:	cb 01       	movw	r24, r22
    7f80:	07 df       	rcall	.-498    	; 0x7d90 <FLASH_readByte>
    putch(FLASH_readByte(1));
    7f82:	ff de       	rcall	.-514    	; 0x7d82 <putch>
    7f84:	61 e0       	ldi	r22, 0x01	; 1
    7f86:	70 e0       	ldi	r23, 0x00	; 0
    7f88:	80 e0       	ldi	r24, 0x00	; 0
    7f8a:	90 e0       	ldi	r25, 0x00	; 0
    7f8c:	01 df       	rcall	.-510    	; 0x7d90 <FLASH_readByte>
    putch(FLASH_readByte(2));
    7f8e:	f9 de       	rcall	.-526    	; 0x7d82 <putch>
    7f90:	62 e0       	ldi	r22, 0x02	; 2
    7f92:	70 e0       	ldi	r23, 0x00	; 0
    7f94:	80 e0       	ldi	r24, 0x00	; 0
    7f96:	90 e0       	ldi	r25, 0x00	; 0
    7f98:	fb de       	rcall	.-522    	; 0x7d90 <FLASH_readByte>
    putch(FLASH_readByte(6));
    7f9a:	f3 de       	rcall	.-538    	; 0x7d82 <putch>
    7f9c:	66 e0       	ldi	r22, 0x06	; 6
    7f9e:	70 e0       	ldi	r23, 0x00	; 0
    7fa0:	80 e0       	ldi	r24, 0x00	; 0
    7fa2:	90 e0       	ldi	r25, 0x00	; 0
    7fa4:	f5 de       	rcall	.-534    	; 0x7d90 <FLASH_readByte>
    7fa6:	ed de       	rcall	.-550    	; 0x7d82 <putch>
    putch(FLASH_readByte(9));
    7fa8:	69 e0       	ldi	r22, 0x09	; 9
    7faa:	70 e0       	ldi	r23, 0x00	; 0
    7fac:	80 e0       	ldi	r24, 0x00	; 0
    7fae:	90 e0       	ldi	r25, 0x00	; 0
    7fb0:	ef de       	rcall	.-546    	; 0x7d90 <FLASH_readByte>
    7fb2:	e7 de       	rcall	.-562    	; 0x7d82 <putch>
    7fb4:	60 e0       	ldi	r22, 0x00	; 0
  #endif
  if (FLASH_readByte(0)=='F' && FLASH_readByte(1)=='L' && FLASH_readByte(2)=='X' && FLASH_readByte(6)==':' && FLASH_readByte(9)==':')
    7fb6:	70 e0       	ldi	r23, 0x00	; 0
    7fb8:	cb 01       	movw	r24, r22
    7fba:	ea de       	rcall	.-556    	; 0x7d90 <FLASH_readByte>
    7fbc:	86 34       	cpi	r24, 0x46	; 70
    7fbe:	09 f0       	breq	.+2      	; 0x7fc2 <CheckFlashImage+0x7e>
    7fc0:	01 c1       	rjmp	.+514    	; 0x81c4 <optiboot_version+0x1c6>
    7fc2:	61 e0       	ldi	r22, 0x01	; 1
    7fc4:	70 e0       	ldi	r23, 0x00	; 0
    7fc6:	80 e0       	ldi	r24, 0x00	; 0
    7fc8:	90 e0       	ldi	r25, 0x00	; 0
    7fca:	e2 de       	rcall	.-572    	; 0x7d90 <FLASH_readByte>
    7fcc:	8c 34       	cpi	r24, 0x4C	; 76
    7fce:	09 f0       	breq	.+2      	; 0x7fd2 <CheckFlashImage+0x8e>
    7fd0:	f9 c0       	rjmp	.+498    	; 0x81c4 <optiboot_version+0x1c6>
    7fd2:	62 e0       	ldi	r22, 0x02	; 2
    7fd4:	70 e0       	ldi	r23, 0x00	; 0
    7fd6:	80 e0       	ldi	r24, 0x00	; 0
    7fd8:	90 e0       	ldi	r25, 0x00	; 0
    7fda:	da de       	rcall	.-588    	; 0x7d90 <FLASH_readByte>
    7fdc:	88 35       	cpi	r24, 0x58	; 88
    7fde:	09 f0       	breq	.+2      	; 0x7fe2 <CheckFlashImage+0x9e>
    7fe0:	f1 c0       	rjmp	.+482    	; 0x81c4 <optiboot_version+0x1c6>
    7fe2:	66 e0       	ldi	r22, 0x06	; 6
    7fe4:	70 e0       	ldi	r23, 0x00	; 0
    7fe6:	80 e0       	ldi	r24, 0x00	; 0
    7fe8:	90 e0       	ldi	r25, 0x00	; 0
    7fea:	d2 de       	rcall	.-604    	; 0x7d90 <FLASH_readByte>
    7fec:	8a 33       	cpi	r24, 0x3A	; 58
    7fee:	09 f0       	breq	.+2      	; 0x7ff2 <CheckFlashImage+0xae>
    7ff0:	e9 c0       	rjmp	.+466    	; 0x81c4 <optiboot_version+0x1c6>
    7ff2:	69 e0       	ldi	r22, 0x09	; 9
    7ff4:	70 e0       	ldi	r23, 0x00	; 0
    7ff6:	80 e0       	ldi	r24, 0x00	; 0
    7ff8:	90 e0       	ldi	r25, 0x00	; 0
    7ffa:	ca de       	rcall	.-620    	; 0x7d90 <FLASH_readByte>
    7ffc:	8a 33       	cpi	r24, 0x3A	; 58
    7ffe:	09 f0       	breq	.+2      	; 0x8002 <optiboot_version+0x4>
    8000:	e1 c0       	rjmp	.+450    	; 0x81c4 <optiboot_version+0x1c6>
  {
#ifdef DEBUG_ON
    putch('L');
    8002:	8c e4       	ldi	r24, 0x4C	; 76
    8004:	be de       	rcall	.-644    	; 0x7d82 <putch>
    8006:	67 e0       	ldi	r22, 0x07	; 7
#endif
    
    uint16_t imagesize = (FLASH_readByte(7)<<8) | FLASH_readByte(8);
    8008:	70 e0       	ldi	r23, 0x00	; 0
    800a:	80 e0       	ldi	r24, 0x00	; 0
    800c:	90 e0       	ldi	r25, 0x00	; 0
    800e:	c0 de       	rcall	.-640    	; 0x7d90 <FLASH_readByte>
    8010:	c8 2f       	mov	r28, r24
    8012:	68 e0       	ldi	r22, 0x08	; 8
    8014:	70 e0       	ldi	r23, 0x00	; 0
    8016:	80 e0       	ldi	r24, 0x00	; 0
    8018:	90 e0       	ldi	r25, 0x00	; 0
    801a:	ba de       	rcall	.-652    	; 0x7d90 <FLASH_readByte>
    801c:	d0 e0       	ldi	r29, 0x00	; 0
    801e:	dc 2f       	mov	r29, r28
    8020:	cc 27       	eor	r28, r28
    8022:	c8 2b       	or	r28, r24
    8024:	c0 fd       	sbrc	r28, 0
    8026:	db c0       	rjmp	.+438    	; 0x81de <optiboot_version+0x1e0>
    if (imagesize%2!=0) return; //basic check that we got even # of bytes
    8028:	31 9a       	sbi	0x06, 1	; 6
    
    uint16_t b, i, nextAddress=0;
    
    LED_PIN |= _BV(LED);
    802a:	c1 2c       	mov	r12, r1
#endif
    
    uint16_t imagesize = (FLASH_readByte(7)<<8) | FLASH_readByte(8);
    if (imagesize%2!=0) return; //basic check that we got even # of bytes
    
    uint16_t b, i, nextAddress=0;
    802c:	d1 2c       	mov	r13, r1
    802e:	00 e0       	ldi	r16, 0x00	; 0
    
    LED_PIN |= _BV(LED);
    for (i=0; i<imagesize; i+=2)
    8030:	10 e0       	ldi	r17, 0x00	; 0
    8032:	bb 24       	eor	r11, r11
#endif
      
      //read 2 bytes (16 bits) from flash image, transfer them to page buffer
      b = FLASH_readByte(i+10); // flash image starts at position 10 on the external flash memory: FLX:XX:FLASH_IMAGE_BYTES_HERE...... (XX = two size bytes)
      b |= FLASH_readByte(i+11) << 8; //bytes are stored big endian on external flash, need to flip the bytes to little endian for transfer to internal flash
      __boot_page_fill_short((uint16_t)(void*)i,b);
    8034:	b3 94       	inc	r11

      //when 1 page is full (or we're on the last page), write it to the internal flash memory
      if ((i+2)%SPM_PAGESIZE==0 || (i+2==imagesize))
      {
        __boot_page_erase_short((uint16_t)(void*)nextAddress); //(i+2-SPM_PAGESIZE)
    8036:	83 e0       	ldi	r24, 0x03	; 3
    8038:	a8 2e       	mov	r10, r24
        boot_spm_busy_wait();
        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)nextAddress ); //(i+2-SPM_PAGESIZE)
    803a:	95 e0       	ldi	r25, 0x05	; 5
    803c:	99 2e       	mov	r9, r25
    if (imagesize%2!=0) return; //basic check that we got even # of bytes
    
    uint16_t b, i, nextAddress=0;
    
    LED_PIN |= _BV(LED);
    for (i=0; i<imagesize; i+=2)
    803e:	0c 17       	cp	r16, r28
    8040:	1d 07       	cpc	r17, r29
    8042:	08 f0       	brcs	.+2      	; 0x8046 <optiboot_version+0x48>
    8044:	30 c0       	rjmp	.+96     	; 0x80a6 <optiboot_version+0xa8>
    {
#ifdef DEBUG_ON
      putch('*');
    8046:	8a e2       	ldi	r24, 0x2A	; 42
    8048:	9c de       	rcall	.-712    	; 0x7d82 <putch>
    804a:	b8 01       	movw	r22, r16
#endif
      
      //read 2 bytes (16 bits) from flash image, transfer them to page buffer
      b = FLASH_readByte(i+10); // flash image starts at position 10 on the external flash memory: FLX:XX:FLASH_IMAGE_BYTES_HERE...... (XX = two size bytes)
    804c:	66 5f       	subi	r22, 0xF6	; 246
    804e:	7f 4f       	sbci	r23, 0xFF	; 255
    8050:	80 e0       	ldi	r24, 0x00	; 0
    8052:	90 e0       	ldi	r25, 0x00	; 0
    8054:	9d de       	rcall	.-710    	; 0x7d90 <FLASH_readByte>
    8056:	e8 2e       	mov	r14, r24
    8058:	f1 2c       	mov	r15, r1
    805a:	b8 01       	movw	r22, r16
    805c:	65 5f       	subi	r22, 0xF5	; 245
      b |= FLASH_readByte(i+11) << 8; //bytes are stored big endian on external flash, need to flip the bytes to little endian for transfer to internal flash
    805e:	7f 4f       	sbci	r23, 0xFF	; 255
    8060:	80 e0       	ldi	r24, 0x00	; 0
    8062:	90 e0       	ldi	r25, 0x00	; 0
    8064:	95 de       	rcall	.-726    	; 0x7d90 <FLASH_readByte>
    8066:	f8 2a       	or	r15, r24
    8068:	f8 01       	movw	r30, r16
    806a:	07 01       	movw	r0, r14
      __boot_page_fill_short((uint16_t)(void*)i,b);
    806c:	b7 be       	out	0x37, r11	; 55
    806e:	e8 95       	spm
    8070:	11 24       	eor	r1, r1
    8072:	0e 5f       	subi	r16, 0xFE	; 254
    8074:	1f 4f       	sbci	r17, 0xFF	; 255
    8076:	c8 01       	movw	r24, r16

      //when 1 page is full (or we're on the last page), write it to the internal flash memory
      if ((i+2)%SPM_PAGESIZE==0 || (i+2==imagesize))
    8078:	8f 77       	andi	r24, 0x7F	; 127
    807a:	99 27       	eor	r25, r25
    807c:	89 2b       	or	r24, r25
    807e:	19 f0       	breq	.+6      	; 0x8086 <optiboot_version+0x88>
    8080:	c0 17       	cp	r28, r16
    8082:	d1 07       	cpc	r29, r17
    8084:	e1 f6       	brne	.-72     	; 0x803e <optiboot_version+0x40>
    8086:	f6 01       	movw	r30, r12
    8088:	a7 be       	out	0x37, r10	; 55
      {
        __boot_page_erase_short((uint16_t)(void*)nextAddress); //(i+2-SPM_PAGESIZE)
    808a:	e8 95       	spm
    808c:	07 b6       	in	r0, 0x37	; 55
    808e:	00 fc       	sbrc	r0, 0
        boot_spm_busy_wait();
    8090:	fd cf       	rjmp	.-6      	; 0x808c <optiboot_version+0x8e>
    8092:	f6 01       	movw	r30, r12
    8094:	97 be       	out	0x37, r9	; 55
        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)nextAddress ); //(i+2-SPM_PAGESIZE)
    8096:	e8 95       	spm
    8098:	07 b6       	in	r0, 0x37	; 55
    809a:	00 fc       	sbrc	r0, 0
        boot_spm_busy_wait();
    809c:	fd cf       	rjmp	.-6      	; 0x8098 <optiboot_version+0x9a>
    809e:	f0 e8       	ldi	r31, 0x80	; 128
    80a0:	cf 0e       	add	r12, r31
        nextAddress += SPM_PAGESIZE;
    80a2:	d1 1c       	adc	r13, r1
    80a4:	cc cf       	rjmp	.-104    	; 0x803e <optiboot_version+0x40>
    80a6:	31 98       	cbi	0x06, 1	; 6
      }
    }
    LED_PIN &= ~_BV(LED);
    80a8:	81 e1       	ldi	r24, 0x11	; 17

#if defined(RWWSRE)
    // Reenable read access to flash
    boot_rww_enable();
    80aa:	87 bf       	out	0x37, r24	; 55
    80ac:	e8 95       	spm
    80ae:	85 e4       	ldi	r24, 0x45	; 69
#endif

#ifdef DEBUG_ON
    putch('E');
    80b0:	68 de       	rcall	.-816    	; 0x7d82 <putch>
    80b2:	99 ec       	ldi	r25, 0xC9	; 201
    80b4:	34 ea       	ldi	r19, 0xA4	; 164
    80b6:	40 ea       	ldi	r20, 0xA0	; 160
        return;
begin:

    /* Note [15] */
    m = 0;
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send start condition */
    80b8:	24 e8       	ldi	r18, 0x84	; 132
	                  /* NB: do /not/ send stop condition */
    }

    /* send SLA+W */
    m = 0;
    TWDR = sla | TW_WRITE;
    80ba:	91 50       	subi	r25, 0x01	; 1
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    80bc:	09 f4       	brne	.+2      	; 0x80c0 <optiboot_version+0xc2>
    80be:	7f c0       	rjmp	.+254    	; 0x81be <optiboot_version+0x1c0>
    uint8_t sla, n = 0, m = 0;

    sla = I2C_EEPROM_ADDR;

restart:
    if (n++ >= MAX_ITER)
    80c0:	30 93 bc 00 	sts	0x00BC, r19	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
        return;
begin:

    /* Note [15] */
    m = 0;
    TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); /* send start condition */
    80c4:	80 e0       	ldi	r24, 0x00	; 0
    80c6:	50 91 bc 00 	lds	r21, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    80ca:	57 fd       	sbrc	r21, 7
    80cc:	06 c0       	rjmp	.+12     	; 0x80da <optiboot_version+0xdc>
    80ce:	8f 5f       	subi	r24, 0xFF	; 255
    80d0:	8b 3f       	cpi	r24, 0xFB	; 251
    80d2:	c9 f7       	brne	.-14     	; 0x80c6 <optiboot_version+0xc8>
    80d4:	81 e4       	ldi	r24, 0x41	; 65
    80d6:	55 de       	rcall	.-854    	; 0x7d82 <putch>
    if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('A');
    80d8:	72 c0       	rjmp	.+228    	; 0x81be <optiboot_version+0x1c0>
    80da:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    80de:	88 7f       	andi	r24, 0xF8	; 248
#endif
		return;
	}
    switch ((twst = TW_STATUS)) {
    80e0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    80e4:	80 31       	cpi	r24, 0x10	; 16
    80e6:	29 f0       	breq	.+10     	; 0x80f2 <optiboot_version+0xf4>
    80e8:	88 33       	cpi	r24, 0x38	; 56
    80ea:	51 f3       	breq	.-44     	; 0x80c0 <optiboot_version+0xc2>
    80ec:	88 30       	cpi	r24, 0x08	; 8
    80ee:	09 f0       	breq	.+2      	; 0x80f2 <optiboot_version+0xf4>
    80f0:	66 c0       	rjmp	.+204    	; 0x81be <optiboot_version+0x1c0>
    80f2:	40 93 bb 00 	sts	0x00BB, r20	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    80f6:	20 93 bc 00 	sts	0x00BC, r18	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	                  /* NB: do /not/ send stop condition */
    }

    /* send SLA+W */
    m = 0;
    TWDR = sla | TW_WRITE;
    80fa:	80 e0       	ldi	r24, 0x00	; 0
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    80fc:	50 91 bc 00 	lds	r21, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	          return;		/* error: not in start condition */
	                  /* NB: do /not/ send stop condition */
    }

    /* send SLA+W */
    m = 0;
    8100:	57 fd       	sbrc	r21, 7
    TWDR = sla | TW_WRITE;
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    8102:	05 c0       	rjmp	.+10     	; 0x810e <optiboot_version+0x110>
    8104:	8f 5f       	subi	r24, 0xFF	; 255
    8106:	8b 3f       	cpi	r24, 0xFB	; 251
    8108:	c9 f7       	brne	.-14     	; 0x80fc <optiboot_version+0xfe>
    810a:	82 e4       	ldi	r24, 0x42	; 66
    810c:	19 c0       	rjmp	.+50     	; 0x8140 <optiboot_version+0x142>
    if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('B');
    810e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
#endif
		goto error;
	}
    switch ((twst = TW_STATUS)) {
    8112:	88 7f       	andi	r24, 0xF8	; 248
    8114:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    8118:	80 32       	cpi	r24, 0x20	; 32
    811a:	79 f2       	breq	.-98     	; 0x80ba <optiboot_version+0xbc>
    811c:	88 33       	cpi	r24, 0x38	; 56
    811e:	81 f2       	breq	.-96     	; 0x80c0 <optiboot_version+0xc2>
    8120:	88 31       	cpi	r24, 0x18	; 24
    8122:	09 f0       	breq	.+2      	; 0x8126 <optiboot_version+0x128>
    8124:	49 c0       	rjmp	.+146    	; 0x81b8 <optiboot_version+0x1ba>
    8126:	10 92 bb 00 	sts	0x00BB, r1	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	      default:
	          goto error;		/* must send stop condition */
    }

#ifdef WORD_ADDRESS_16BIT
    TWDR = 0; m = 0;
    812a:	20 93 bc 00 	sts	0x00BC, r18	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    812e:	80 e0       	ldi	r24, 0x00	; 0
    8130:	50 91 bc 00 	lds	r21, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)) ; /* wait for transmission */
    8134:	57 fd       	sbrc	r21, 7
    8136:	06 c0       	rjmp	.+12     	; 0x8144 <optiboot_version+0x146>
    8138:	8f 5f       	subi	r24, 0xFF	; 255
    813a:	8b 3f       	cpi	r24, 0xFB	; 251
    813c:	c9 f7       	brne	.-14     	; 0x8130 <optiboot_version+0x132>
    813e:	83 e4       	ldi	r24, 0x43	; 67
    8140:	20 de       	rcall	.-960    	; 0x7d82 <putch>
    if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('C');
    8142:	3a c0       	rjmp	.+116    	; 0x81b8 <optiboot_version+0x1ba>
    8144:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    8148:	88 7f       	andi	r24, 0xF8	; 248
#endif
		goto error;
	}
    switch ((twst = TW_STATUS)) {
    814a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    814e:	88 32       	cpi	r24, 0x28	; 40
    8150:	a9 f4       	brne	.+42     	; 0x817c <optiboot_version+0x17e>
    8152:	10 92 bb 00 	sts	0x00BB, r1	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    8156:	20 93 bc 00 	sts	0x00BC, r18	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	          goto error;		/* must send stop condition */
    }
#endif

    m = 0;
    TWDR = 0;		/* low 8 bits of addr */
    815a:	80 e0       	ldi	r24, 0x00	; 0
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    815c:	50 91 bc 00 	lds	r21, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	      default:
	          goto error;		/* must send stop condition */
    }
#endif

    m = 0;
    8160:	57 fd       	sbrc	r21, 7
    TWDR = 0;		/* low 8 bits of addr */
    TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
    while (((TWCR & _BV(TWINT)) == 0) && (m++ < MAX_TIMEOUT)); /* wait for transmission */
    8162:	05 c0       	rjmp	.+10     	; 0x816e <optiboot_version+0x170>
    8164:	8f 5f       	subi	r24, 0xFF	; 255
    8166:	8b 3f       	cpi	r24, 0xFB	; 251
    8168:	c9 f7       	brne	.-14     	; 0x815c <optiboot_version+0x15e>
    816a:	84 e4       	ldi	r24, 0x44	; 68
    816c:	e9 cf       	rjmp	.-46     	; 0x8140 <optiboot_version+0x142>
    816e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
		putch('D');
    8172:	88 7f       	andi	r24, 0xF8	; 248
#endif
		goto error;
	}
    switch ((twst = TW_STATUS)) {
    8174:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    8178:	88 32       	cpi	r24, 0x28	; 40
    817a:	21 f0       	breq	.+8      	; 0x8184 <optiboot_version+0x186>
    817c:	88 33       	cpi	r24, 0x38	; 56
    817e:	09 f4       	brne	.+2      	; 0x8182 <optiboot_version+0x184>
    8180:	9f cf       	rjmp	.-194    	; 0x80c0 <optiboot_version+0xc2>
    8182:	1a c0       	rjmp	.+52     	; 0x81b8 <optiboot_version+0x1ba>
    8184:	98 e0       	ldi	r25, 0x08	; 8
    8186:	2f ef       	ldi	r18, 0xFF	; 255
    8188:	34 e8       	ldi	r19, 0x84	; 132
	          goto error;		/* must send stop condition */
    }

    // write 8 times 0xFF
    for (n=8; n ; n--) {
	      TWDR = 0xFF; m = 0;
    818a:	20 93 bb 00 	sts	0x00BB, r18	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    818e:	30 93 bc 00 	sts	0x00BC, r19	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	      TWCR = _BV(TWINT) | _BV(TWEN); /* start transmission */
    8192:	80 e0       	ldi	r24, 0x00	; 0
    8194:	40 91 bc 00 	lds	r20, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	      while (((TWCR & _BV(TWINT)) == 0)  && (m++ < MAX_TIMEOUT)); /* wait for transmission */
    8198:	47 fd       	sbrc	r20, 7
    819a:	05 c0       	rjmp	.+10     	; 0x81a6 <optiboot_version+0x1a8>
    819c:	8f 5f       	subi	r24, 0xFF	; 255
    819e:	8b 3f       	cpi	r24, 0xFB	; 251
    81a0:	c9 f7       	brne	.-14     	; 0x8194 <optiboot_version+0x196>
    81a2:	85 e4       	ldi	r24, 0x45	; 69
	      if (m > MAX_TIMEOUT) {
#ifdef DEBUG_ON
			putch('E');
    81a4:	cd cf       	rjmp	.-102    	; 0x8140 <optiboot_version+0x142>
    81a6:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
#endif
			goto error;
		  }
	      switch ((twst = TW_STATUS)) {
    81aa:	88 7f       	andi	r24, 0xF8	; 248
    81ac:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
    81b0:	88 32       	cpi	r24, 0x28	; 40
    81b2:	11 f4       	brne	.+4      	; 0x81b8 <optiboot_version+0x1ba>
    81b4:	91 50       	subi	r25, 0x01	; 1
    81b6:	49 f7       	brne	.-46     	; 0x818a <optiboot_version+0x18c>
	      default:
	          goto error;		/* must send stop condition */
    }

    // write 8 times 0xFF
    for (n=8; n ; n--) {
    81b8:	84 e9       	ldi	r24, 0x94	; 148
		            goto error;
	      }
    }

quit:
    TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
    81ba:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
#else
    EEPROM_invalidate();
#endif

    //now trigger a watchdog reset
    watchdogConfig(WATCHDOG_16MS);  // short WDT timeout
    81be:	88 e0       	ldi	r24, 0x08	; 8
    81c0:	b6 de       	rcall	.-660    	; 0x7f2e <watchdogConfig>
    81c2:	ff cf       	rjmp	.-2      	; 0x81c2 <optiboot_version+0x1c4>
    while (1); 		                  // and busy-loop so that WD causes a reset and app start
  }
#ifdef DEBUG_ON
  putch('X');
    81c4:	88 e5       	ldi	r24, 0x58	; 88
#endif
}
    81c6:	df 91       	pop	r29
    81c8:	cf 91       	pop	r28
    81ca:	1f 91       	pop	r17
    81cc:	0f 91       	pop	r16
    81ce:	ff 90       	pop	r15
    81d0:	ef 90       	pop	r14
    81d2:	df 90       	pop	r13
    81d4:	cf 90       	pop	r12
    //now trigger a watchdog reset
    watchdogConfig(WATCHDOG_16MS);  // short WDT timeout
    while (1); 		                  // and busy-loop so that WD causes a reset and app start
  }
#ifdef DEBUG_ON
  putch('X');
    81d6:	bf 90       	pop	r11
    81d8:	af 90       	pop	r10
#endif
}
    81da:	9f 90       	pop	r9
    81dc:	d2 cd       	rjmp	.-1116   	; 0x7d82 <putch>
    81de:	df 91       	pop	r29
    81e0:	cf 91       	pop	r28
    81e2:	1f 91       	pop	r17
    81e4:	0f 91       	pop	r16
    81e6:	ff 90       	pop	r15
    81e8:	ef 90       	pop	r14
    81ea:	df 90       	pop	r13
    81ec:	cf 90       	pop	r12
    81ee:	bf 90       	pop	r11
    81f0:	af 90       	pop	r10
  do getch(); while (--count);
  verifySpace();
}

void verifySpace() {
  if (getch() != CRC_EOP) {
    81f2:	9f 90       	pop	r9
    81f4:	08 95       	ret

000081f6 <verifySpace>:
    81f6:	8d de       	rcall	.-742    	; 0x7f12 <getch>
    81f8:	80 32       	cpi	r24, 0x20	; 32
    watchdogConfig(WATCHDOG_16MS);    // shorten WD timeout
    81fa:	19 f0       	breq	.+6      	; 0x8202 <verifySpace+0xc>
    81fc:	88 e0       	ldi	r24, 0x08	; 8
    81fe:	97 de       	rcall	.-722    	; 0x7f2e <watchdogConfig>
    8200:	ff cf       	rjmp	.-2      	; 0x8200 <verifySpace+0xa>
    while (1)			      // and busy-loop so that WD causes
      ;				      //  a reset and app start.
  }
  putch(STK_INSYNC);
    8202:	84 e1       	ldi	r24, 0x14	; 20
    8204:	be cd       	rjmp	.-1156   	; 0x7d82 <putch>

00008206 <getNch>:
    8206:	cf 93       	push	r28
    ::[count] "M" (UART_B_VALUE)
  );
}
#endif

void getNch(uint8_t count) {
    8208:	c8 2f       	mov	r28, r24
    820a:	83 de       	rcall	.-762    	; 0x7f12 <getch>
  do getch(); while (--count);
    820c:	c1 50       	subi	r28, 0x01	; 1
    820e:	e9 f7       	brne	.-6      	; 0x820a <getNch+0x4>
    8210:	cf 91       	pop	r28
    8212:	f1 cf       	rjmp	.-30     	; 0x81f6 <verifySpace>

00008214 <appStart>:
  verifySpace();
}
    8214:	28 2e       	mov	r2, r24
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
  verifySpace();
    8216:	80 e0       	ldi	r24, 0x00	; 0
    8218:	8a de       	rcall	.-748    	; 0x7f2e <watchdogConfig>

void appStart(uint8_t rstFlags) {
  // save the reset flags in the designated register
  //  This can be saved in a main program by putting code in .init0 (which
  //  executes before normal c init code) to save R2 to a global variable.
  __asm__ __volatile__ ("mov r2, %0\n" :: "r" (rstFlags));
    821a:	ee 27       	eor	r30, r30

  watchdogConfig(WATCHDOG_OFF);
    821c:	ff 27       	eor	r31, r31
    821e:	09 94       	ijmp
